import { mkdirp } from "mkdirp";
import fs from "node:fs";
import path from "node:path";

import { DEFAULT_OUTPUT_PATH } from "@/constants";
import {
  checkConfigFile,
  fetchStoryblokDatasource,
  getName,
  getProgramOptions,
  parseDatasourceResponse,
  prettierFormat,
} from "@/utils";

const options = getProgramOptions();

export const init = async () => {
  const config = await checkConfigFile();

  if (!config.api || !config.api?.endpoint || !config.api?.token) {
    logger.error("Missing API config");
    logger.error("Please add an API config to your sb-types.config.cjs file");

    return process.exit(1);
  }

  if (!config.datasources || !config.datasources?.length) {
    logger.error("Missing datasources");
    logger.error(
      "Please add a list of datasources to your sb-types.config.cjs file"
    );

    return process.exit(1);
  }

  if (config) {
    logger.info("Fetching datasources...");

    const promises = config.datasources.map((datasource) =>
      fetchStoryblokDatasource(config.api.endpoint, config.api.token, {
        datasource: datasource.name,
        per_page: datasource.amount || 250,
        cv: config.cache_validation || new Date().toISOString(),
      })
    );

    const responses = await Promise.all(promises);

    let result: Record<
      string,
      {
        datasource: {
          data: string[];
          name: string;
        }[];
        overwrite: boolean;
        path: string;
      }
    > = {};

    responses.forEach(async (response, index) => {
      const datasource = config.datasources[index];
      logger.success(`Datasource ${datasource.name} fetched!`);

      const fullPath = config.outputPath || DEFAULT_OUTPUT_PATH;
      const fileName = datasource.outputFile || path.basename(fullPath);

      const dirPath = path.dirname(fullPath);

      const outputPath = `${dirPath}/${fileName}`;

      if (fileName in result) {
        result[fileName].datasource = result[fileName].datasource.concat({
          data: [parseDatasourceResponse(response, datasource.name)],
          name: datasource.name,
        });
      } else {
        result[fileName] = {
          datasource: [
            {
              data: [parseDatasourceResponse(response, datasource.name)],
              name: datasource.name,
            },
          ],
          overwrite: options.overwrite,
          path: outputPath,
        };
      }
    });

    Object.keys(result).forEach(async (key) => {
      const { datasource, overwrite, path: pathString } = result[key];

      const outputPath = path.join(process.cwd(), pathString);
      mkdirp.sync(path.dirname(outputPath)); // this will create the directory if it does NOT exists

      const dataString = `
        // Generated by ${getName()}: ${new Date().toISOString()}

        ${datasource
          .map((ds) => `// Datasource: ${ds.name}${ds.data}\n`)
          .join("\n")}
      `;

      const output = options.prettier
        ? await prettierFormat(dataString)
        : dataString;

      if (overwrite) {
        fs.writeFileSync(outputPath, output);
        logger.success(
          `Datasource overwritten to ${pathString} (overwrite enabled)`
        );
      } else {
        if (fs.existsSync(outputPath)) {
          fs.appendFileSync(outputPath, `\n${output}`);
          logger.success(`Datasource appended to ${pathString}`);
          return;
        } else {
          fs.writeFileSync(outputPath, output);
          logger.success(`Datasource saved to ${pathString}`);
        }
      }
    });
  }
};
